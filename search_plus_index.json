{"./":{"url":"./","title":"主页","keywords":"","body":"ZBook Python ML NLP 算法 Linux 数据库 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-31 "},"question/Py/":{"url":"question/Py/","title":"Python","keywords":"","body":"Python 常见的理论知识点与问题 Python基本数据类型 不可变类型： int/float/bool/complex(复数) str '' tuple () 可变类型： list [] dict {} set set() 匿名函数 没有名字的函数 语法：lambda [形参1],[形参2],...:[单行表达式]/[函数调用] 列表推导式 语法：[x for x in range(1,101)] 命名空间 一个命名系统，可以理解为一个作用域里不可以有两个一模一样的实体，确保唯一性，避免命名冲突。 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/ML/":{"url":"question/ML/","title":"ML","keywords":"","body":"机器学习 无监督学习 关联规则：发生不同事物之间的关系。在数据库的候选项集中用来挖掘出现频繁的项集，并发现他们之间的关联规则。 Apriori算法 聚类问题：相似样本划分为一个簇，与分类问题不同点：聚类预先并不知道类别。 K-means算法 降维：减少数据的维度同时保证不丢失有意义的信息。（通过特征提取、特征选择） PCA(主成分分析) Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-31 "},"question/NLP/":{"url":"question/NLP/","title":"NLP","keywords":"","body":"NLP 常见的理论知识点与问题 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/a.理论.html":{"url":"question/NLP/a.理论.html","title":"a.理论问题","keywords":"","body":"理论 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-04-02 "},"question/NLP/b.数据.html":{"url":"question/NLP/b.数据.html","title":"b.数据问题","keywords":"","body":"数据 文本预处理 基本处理方法 分词 jieba（自定义词典） 全模式 精确模式 搜索引擎模式 词性标注（POS） hanlp 命名实体识别（NER） hanlp 张量表示 one-hot 操作简单 完全割裂词与词之间的联系，且预料越大引发维度灾难 word2vec 训练模式 CBOW 上下文词汇预测目标词 Skipgram 目标词预测上下文词汇 工具：fastText model = fasttext.train_unsupervised('datafile')# 无监督训练词向量 model.get_word_vector(\"word\")# 获取word词向量 word Embedding(词嵌入) 将词汇映射到指定维度空间 广义：所有密集词汇向量 狭义：神经网络中的embedding层（embedding矩阵：训练中所有输入词汇的向量组成的矩阵） 文本语料数据分析 标签数量分布 句子长度分布 词频统计与关键词词云 文本特征 n-gram特征 文本长度规范 数据增强 回译增强 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/c.模型.html":{"url":"question/NLP/c.模型.html","title":"c.模型问题","keywords":"","body":"模型 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/d.部署.html":{"url":"question/NLP/d.部署.html","title":"d.部署问题","keywords":"","body":"部署 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/e.优化.html":{"url":"question/NLP/e.优化.html","title":"e.优化问题","keywords":"","body":"优化 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/ALG/":{"url":"question/ALG/","title":"算法","keywords":"","body":"算法 数据结构 树 排序 动态规划 常见题 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-04-01 "},"question/ALG/数据结构.html":{"url":"question/ALG/数据结构.html","title":"数据结构","keywords":"","body":"数据结构 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-27 "},"question/ALG/树.html":{"url":"question/ALG/树.html","title":"树","keywords":"","body":"树 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-27 "},"question/ALG/查找.html":{"url":"question/ALG/查找.html","title":"查找","keywords":"","body":"查找 顺序查找：O(N) O(1) from typing import List def seq_search(nums:List[int],n): for i,v in nums: if n == v: return i return -1 二分查找 from typing import List def b_search(nums:List[int],X): def binarySearch(arr, l, r, x): if l x: return binarySearch(arr, l, mid-1, x) while else: return mid else: return -1 return binarySearch(nums,0,len(nums)-1,X) # 测试代码 arr = [1,5,8,9] X = 8 print(b_search(arr,X)) 找出只出现一次的元素 from functools import reduce from typing import List import random class Solution: def singleNumber(self, nums: List[int]) -> int: return reduce(lambda x, y: x ^ y, nums) #测试代码 lst = [i for i in range(101)] lst.extend(lst);lst.remove(20);random.shuffle(lst) print(Solution().singleNumber(lst)) 找出重复出现的元素 from typing import List import random class Solution: # 1.异或法:O(N) O(1) 需要前提条件 # 异或法控制了空间复杂度O(1) # 1-100的数，放在101位数组中，多出的一位是重复元素，找出该元素。A^A^B = B # 此方法全部计算后才能得到结果，而其他方法可以在中途找到直接return # 重要条件:因为所有的B都必须异或一次，所以要求1-100的数字都必须出现 def findRepeatNumber(self,nums: List[int]) -> int: tmp = nums[0] for i in enumerate(nums[1:]): tmp ^= (i[0] ^ i[1]) return tmp # 2.下标定位之元素交换法:O(N)O(1) # 数组元素交换控制了空间复杂度O(1) # 但是也导致了前提条件：数组中元素的最大值必须小于数组的长度。(MAX int: for i,v in enumerate(nums): if v != i: if nums[v] == v: return v nums[v] , nums[i] = v , nums[v] return -1 # 3.哈希表中介法:O(N)O(N) def findRepeatNumber3(self,nums:List[int]) -> int: _dict = {} for v in nums: if v in _dict: return v _dict[v] = '' return -1 # 4.排序判断法:O(NlogN)O(1) def findRepeatNumber4(self, nums): nums.sort() pre = nums[0] for index in range(1, len(nums)): if pre == nums[index]: return pre pre = nums[index] # 测试代码 lst = [i for i in range(101)] lst.append(10);random.shuffle(lst) print(Solution().findRepeatNumber(lst)) print(Solution().findRepeatNumber2(lst)) print(Solution().findRepeatNumber3(lst)) print(Solution().findRepeatNumber4(lst)) ... Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-04-03 "},"question/ALG/排序.html":{"url":"question/ALG/排序.html","title":"排序","keywords":"","body":"常用排序 哈希排序：O(N) O(1) 基本思想：利用桶概念哈希排序，将数组中的值映射到有限的O(1)数值表中.类型：TF-IDF 前提：桶的个数必须大于排序数组中最大值，可以自定义，也可以用max()获取 过程： 生成一个有限的数值映射数组 遍历排序数组，将其在映射数组中的频次+1 遍历映射数组，将所有位置的数值放入原数组中（为了不增加空间复杂度），放入次数=频次 说明： 传说中的时间复杂度O(N)排序。因为桶被当成了常量，严格可以看作：O（N+MAX） 空间复杂度O(1)。因为映射表长度也被看作常量，严格可以看作：O(MAX) 代码：from typing import List # 长度必须大于数组中最大值 MAX = 65535 def hash_sort(nums:List[int]): MAX = max(nums)+1 lst = MAX * [0] for i in nums: lst[i] += 1 index = 0 for i in enumerate(lst): for j in range(i[1]): nums[index] = i[0] index += 1 return nums 桶排序：O(N+K) O(n*k) 基本思想：构建N个桶,将数组中放置到各区间的桶内，进行小范围排序后依次取出。 过程： 构建N各桶，N = (MAX-MIN)/len 遍历数组，数组中的数置于各区间桶中 小桶排序 取出数，合并（此处使用了sum()高级用法） 说明：因为此处的sorted是O(NlogN)，但是它是经过分类后的小范围快排，故在比较上忽略掉了。 代码： def bucket_sort(arr): max_,min_=max(arr),min(arr) stride=(max_-min_)/len(arr) buckets=[[] for i in range(len(arr)+1)] for num in arr: buckets[int((num-min_)//stride)].append(num) arr = [sorted(bucket) for bucket in buckets] return sum(arr,[])# sum高级用法，加和从[]开始（二维数组中[]开始） print(bucket_sort([54,26,93,21,17,77,31,44,55,20])) 快速排序：O(NlogN) O(logN) 基本思想: 选出一个数，不断切分成大、小数组。 过程: 从数组中取出一个数：key 将比key小的置左，将比key大的置后 对左右两个小数组重复步骤二，直到小数组无法再分 复杂度：时间O(NlogN) 空间O(logN) 代码: # 快排写法 def quicksort(arr, low, high): if low arr[0]] return quick_sort(l) + [arr[0]] + quick_sort(r) # lambda一行写法 q_sort = lambda x: [] if len(x) == 0 else \\ q_sort([s for s in x[1:] if s x[0]]) 插入排序：O(N²) O(1) 基本思想：构建有序序列，将未排序的数据，在已排序的序列中从后向前扫描，插入到相应位置。 过程： 假设第一个数位置已排序好 从第二个数开始与前面的比较，小数前移，不断优化前置的顺序数列 复杂度：时间O(N²) 空间O(1) 代码： # 插入 def insertionSort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key 冒泡排序：O(N²) O(1) 基本思想：比较相邻两个数的大小，较大的下沉，较小的前置 过程： 比较两个数，若后面的数小，交换位置（小数前置/大数后置） 两两比较，一直到比较最前的两个数。最终最小的数交换到起始位置 重复执行，将2、3...n-1个最小数排列成功。 优化：设置一个状态，若某轮检索，没有交换任何元素，说明已经排好，直接停止。 复杂度：时间O(N²) 空间O(1) 代码：def bouble_sort(arr: List[int]): l = len(arr) - 1 flag = True # 优化点 i = j = 0 while i arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] flag = False j += 1 if flag: break i += 1 return arr 堆排序：O(NlogN) O(1) 基本思想：利用堆积构建完全二叉树。 过程：（具体步骤需要深入理解） 将列表堆化（完全二叉树）父节点值 > 左右节点值 交换头尾元素后，摘出最大值，破坏堆积后重新进行堆化 依次交换优化堆积后，列表排序成功 复杂度：时间O(NlogN) 空间O(1) 代码： # 堆排序 def heap_sort(tree: List[int]): n = len(tree) # 根据列表，反向构建完全二叉树的堆积 for i in range(n, -1, -1): heapify(tree, n, i) # 依次交换尾、头元素，交换导致破坏堆结构后，再次优化堆积 for i in range(n - 1, 0, -1): tree[i], tree[0] = tree[0], tree[i] heapify(tree, i, 0) return tree # 堆化 def heapify(tree: List[int], n, i): if i >= n: return # 列表堆化的三角节点与索引关系：i父节点p=(i-1)/2 左孩子l=2i+1 右孩子r=2i+2 l = 2 * i + 1 r = 2 * i + 2 max = i # 设法找到最大值 if l tree[i]: max = l if r tree[max]: max = r if max != i: # 找到max后，若max不是原父节点i，交换一下，重新堆化 tree[i], tree[max] = tree[max], tree[i] heapify(tree, n, max) Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-04-03 "},"question/ALG/动态规划.html":{"url":"question/ALG/动态规划.html","title":"动态规划","keywords":"","body":"动态规划 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-27 "},"question/ALG/常见题.html":{"url":"question/ALG/常见题.html","title":"常见题","keywords":"","body":"常见算法 数组中和为某数的两个元素 from typing import List class Solttion: # O(N) 哈希键存储 def sum(self, nums: List[int], target: int) -> List[int]: hash = {} for i, num in enumerate(nums): if target - num in hash: return (hash[target - num], i) hash[nums[i]] = i return () # 暴力 O(NN) def sum2(self, nums: List[int], target: int) -> List[int]: for _,i in enumerate(nums): for __,j in enumerate(nums[_:]): if i+j == target: return _,_+__ # O(N) print(Solttion().sum([1,5,6,8],9)) # O(n*n) print(Solttion().sum2([1,5,6,8],9)) 组合总数 from typing import List class Solution: def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]: candidates = sorted(candidates) ans = [] def find(s, use, remain): for i in range(s, len(candidates)): c = candidates[i] if c == remain: ans.append(use + [c]) if c remain: return find(0, [], target) return ans def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]: dp = [[] for _ in range(target+1)] for i in sorted(candidates,reverse=True): for j in range(i,target+1): if j==i:dp[j] = [[i]];continue dp[j].extend([x+[i] for x in dp[j-i]]) # print(dp) return dp[-1] def combinationSum3(self, candidates: List[int], target: int) -> List[List[int]]: dict = {} for i in range(1,target+1): dict[i]=[] for i in range(1,target+1): for j in candidates: if i==j: dict[i].append([i]) elif i>j: for k in dict[i-j]: x = k[:] x.append(j) x.sort() # 升序，便于后续去重 if x not in dict[i]: dict[i].append(x) return dict[target] # 测试代码 print(len(Solution().combinationSum([1,2,3,4],5))) print(len(Solution().combinationSum2([1,2,3,4],5))) print(len(Solution().combinationSum3([1,2,3,4],5))) 合并有序数组 from typing import List # 方法一 时间复杂度O(m+k),空间复杂度O(k) def merge_list(lst1:List[int],lst2:[int]): l1, l2 = len(lst1), len(lst2) lst1 += l2 * [0] # 控制空间复杂度到k=len(lst2) l1,l2,cur = l1 - 1, l2 - 1,l1 + l2 - 1 while cur >= 0 and l2 >= 0: if lst1[l1] > lst2[l2]: lst1[cur] = lst1[l1] l1 -= 1 else: lst1[cur] = lst2[l2] l2 -= 1 cur -= 1 lst1[:l2+1] = lst2[0:l2+1] return lst1 # 方法二 O(NlogN) 空间复杂度O(k) k=len(lst2) def merge_list2(lst1:List[int],lst2:List[int]): lst1.extend(lst2) lst1.sort() return lst1 print(merge_list([1,3,11],[2,12,15,18])) 斐波那契数列 class Solution: def fib(self, n: int) -> int: a, b = 0, 1 for _ in range(n): # t = b # b = a + b # a = t a, b = b, a + b return a % 1000000007 print(Solution().fib(7)) 青蛙台阶 # 一次可以跳1阶/2阶 class Solution: def numWays(self, n: int) -> int: a, b = 1, 1 for _ in range(n): a, b = b, a + b return a % 1000000007 打印链表 from typing import List class ListNode: def __init__(self, x, next = None): self.val = x self.next = next class Solution: def reversePrint(self, head: ListNode) -> List[int]: res = [] while head: res.append(head.val) head = head.next return res[::-1] print(Solution().reversePrint(ListNode(0,ListNode(1,ListNode(2,ListNode(3,ListNode(4))))))) 替换空格 class Solution: def replaceSpace(self, s: str) -> str: l = len(s) nums = s.count(' ') n_l = l + (nums 数组中查找某个数 from typing import List class Solution: # 二分查找 def find(self, nums: List[List[int]], target: int) -> bool: if not nums or len(nums) == 0 or not nums[0] or len(nums[0]) == 0: return False m, n = len(nums), len(nums[0]) i, j = 0, n - 1 while (i = 0): if target nums[i][j]: i += 1 else: return True return False 有序数组中最小数 from typing import List class Solution: def minArray(self, numbers: List[int]) -> int: left, right = 0, len(numbers) - 1 while left numbers[right]: left = mid + 1 elif numbers[mid] 数组中重复的数 from typing import List class Solution: def findRepeatNumber(self, nums: List[int]) -> int: for i in range(len(nums)): while nums[i] != i: if nums[nums[i]] == nums[i]: return nums[i] nums[nums[i]] , nums[i] = nums[i] , nums[nums[i]] return -1 print(Solution().findRepeatNumber([2, 3, 1, 0, 2, 5, 3])) 机器人(0,0)到(x,y)走法 # 0,0到x,y所有走法（下、右） # 1.暴力递归 def recursion(x, y): if x == 1 or y == 1: return 1 x, y = abs(x), abs(y) return recursion(x-1, y) + recursion(x, y-1) # 2.dp动态规划 def dp_func(x, y): \"\"\" dp[i][0] = 1 for i = 0,...,x-1 dp[0][j] = 1 for j = 0,...,y-1 dp[x][y] = dp[x-1][y] + dp[x][y-1] \"\"\" if x == 0 and y == 0: return 0 if x == 0 or y == 0: return 1 x, y = abs(x), abs(y) dp = [[0 for _ in range(y)] for _ in range(x)] for i in range(x): dp[i][0] = 1 for i in range(y): dp[0][i] = 1 for i in range(1, x): for j in range(1, y): dp[i][j] = dp[i][j-1] + dp[i-1][j] return dp[x-1][y-1] def dp_func2(x,y): dp = [1 for _ in range(x)] for i in range(1,x): for j in range(1,y): dp[j] += dp[j-1] return dp[y-1] print(recursion(4,4)) print(dp_func(4,4)) print(dp_func2(4,4)) 两个数组相对排序 from typing import List class Solution: # 方法一 sort(key) def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]: ranks = {x: i for i, x in enumerate(arr2)} arr1.sort(key=lambda x:(0,ranks[x]) if x in ranks else (1,x)) return arr1 # 方法二 计数排序法 def relativeSortArray2(self,arr1: List[int], arr2: List[int]) -> List[int]: upper = max(arr1) frequency = [0] * (upper + 1) for x in arr1: frequency[x] += 1 ans = list() for x in arr2: ans.extend([x] * frequency[x]) frequency[x] = 0 for x in range(upper + 1): if frequency[x] > 0: ans.extend([x] * frequency[x]) return ans # 通过sort()参数指定键排序 arr1,arr2 = [2,3,1,3,2,4,6,7,9,2,20,19,5,1],[2,4,3,6] print(Solution().relativeSortArray(arr1,arr2)) 二叉树中最近的公共父节点 class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def lowestCommonAncestor(root, p, q): if not root: return root if root.val == p.val or root.val == q.val: return root l = self.lowestCommonAncestor(root.left, p, q) r = self.lowestCommonAncestor(root.right, p, q) if l and r: return root if l: return l if r: return r ... Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-04-03 "},"question/Linux/":{"url":"question/Linux/","title":"Linux","keywords":"","body":"Linux Linux内核操作系统：CentOS、Ubuntu、Redhat 常用命令 进程线程协程 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/Linux/Linux命令.html":{"url":"question/Linux/Linux命令.html","title":"常用命令","keywords":"","body":"Linux命令 常用命令 命令 说明 示例 文件操作 cp 复制 cp a.txt b.txt // cp -r a b mv 移动/修改文件 mv f1 /dir rm -rf 经典的删档入狱指令,谨慎使用 head 从头部打印查看文件 head 1.log -n 5 // head -n -5 t.log tail 从尾部打印查看文件 tail 1.log -n 5 which 执行命令的文件位置 echo $PATH 查看当前 PATH 配置 chmod 修改权限 r:4 w:2 x:1 chmod 751 file find 查找文件 -name -atime -size find . -name '*.log' 压缩/解压 gzip 压:tar -zcvf filename.tar.gz [file/path] 解:tar zxvf filename.tar.gz bz2 压:tar -jcvf filename.tar.bz2 [file/path] 解:tar jxvf filename.tar.bz2 zip 压:zip -q -r file.zip [file/path] 解:unzip file.zip 硬件 free 内存情况 -k:KB -m:MB -g:GB -s:持续查询 free -s 10(间隔十秒查询) du 查看文件及大小 -k:KB -m:MB -g:GB du -mh df -l 硬盘空间 ln -s:软连接 -b:覆盖以前的链接 ln a ../a // ln -s a.log ../b.log 任务进程 PID 查看任务PID ps -ef | grep python // pgrep -f python jobs 查看后台任务%ID kill 终止进程 kill -9 PID // $jobs $kill -9 %jobID pkill 终止进程(程序名) pkill -f name lsof 端口占用 lsof -i:[端口号] Ctrl+Z 停止 Ctrl+C 挂起 其他操作 步骤一 步骤二 CentOS系统时间 rm -rf /etc/localtime ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 基本命令 命令 说明 ls [选项] 查看目录文件 [-a 隐藏文件] tree 以树状方式显示目录信息 pwd 查看当前目录路径 clear 清除终端内容 cd [目录] 切换目录 cd ~ 切换到当前用户的主目录 cd .. 切换到上一级目录 cd . 切换到当前目录 cd - 切换到上一次目录 touch 文件名 创建指定文件 mkdir [!文件夹名] 创建文件夹 [-p 不存在则创建] rm [选项] [文件] 删除文件/目录 [-r 递归] rmdir 目录名 删除空目录 cp 拷贝文件、拷贝目录(-r) [cp 源 目标] mv 移动文件、移动目录、重命名 [mv 源 目标] > 若文件存在会覆盖原有文件内容，‘w’模式 >> 若文件存在会追加写入文件末尾，‘a’ 模式 cat 查看小文件 cat > file 写文件 cat >file.txt content >EOF cat file1 file2 > file 合并文件 cat f1 // cat > f1 // cat f1 f2 > f3 more 分屏查看大型文件 ln 创建硬链接 ln -s 创建软链接 [ln -s 源路径(绝对路径) 软链接] grep 文本搜索 grep -i 忽略大小写 grep '^a' 以字符串a开头 grep 'a$' 以字符串a结尾 find 指定目录下查找文件(包括目录) find -name 文件名(包括目录名)查找 zip 压缩.zip格式文件 unzip 解压.zip格式文件[unzip -d 解压至指定目录] Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/Linux/进程线程协程.html":{"url":"question/Linux/进程线程协程.html","title":"进程线程协程","keywords":"","body":"进程 & 线程 & 协程 进程 进程是操作系统进行资源分配的基本单位。 一个程序运行后至少有一个进程，一个进程默认有一个线程 import multiprocessing def task(): for i in range(10): print(\"任务执行中...\") time.sleep(0.2) sub_process = multiprocessing.Process(target=task, kwargs={\"count\": 3}) sub_process.daemon = True sub_process.start() Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-29 "},"question/DATA/":{"url":"question/DATA/","title":"数据库","keywords":"","body":"Database MySQL Neo4j Redis MongoDB Other Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-29 "}}