{"./":{"url":"./","title":"主页","keywords":"","body":"ZBook Python NLP 算法 Linux Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/Py/":{"url":"question/Py/","title":"Python","keywords":"","body":"Python 常见的理论知识点与问题 Python基本数据类型 不可变类型： int/float/bool/complex(复数) str '' tuple () 可变类型： list [] dict {} set set() 匿名函数 没有名字的函数 语法：lambda [形参1],[形参2],...:[单行表达式]/[函数调用] 列表推导式 语法：[x for x in range(1,101)] 命名空间 一个命名系统，可以理解为一个作用域里不可以有两个一模一样的实体，确保唯一性，避免命名冲突。 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/":{"url":"question/NLP/","title":"NLP","keywords":"","body":"NLP 常见的理论知识点与问题 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/a.理论.html":{"url":"question/NLP/a.理论.html","title":"a.理论问题","keywords":"","body":"理论 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/b.数据.html":{"url":"question/NLP/b.数据.html","title":"b.数据问题","keywords":"","body":"数据 文本预处理 基本处理方法 分词 jieba（自定义词典） 全模式 精确模式 搜索引擎模式 词性标注（POS） hanlp 命名实体识别（NER） hanlp 张量表示 one-hot 操作简单 完全割裂词与词之间的联系，且预料越大引发维度灾难 word2vec 训练模式 CBOW 上下文词汇预测目标词 Skipgram 目标词预测上下文词汇 工具：fastText model = fasttext.train_unsupervised('datafile')# 无监督训练词向量 model.get_word_vector(\"word\")# 获取word词向量 word Embedding(词嵌入) 将词汇映射到指定维度空间 广义：所有密集词汇向量 狭义：神经网络中的embedding层（embedding矩阵：训练中所有输入词汇的向量组成的矩阵） 文本语料数据分析 标签数量分布 句子长度分布 词频统计与关键词词云 文本特征 n-gram特征 文本长度规范 数据增强 回译增强 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/c.模型.html":{"url":"question/NLP/c.模型.html","title":"c.模型问题","keywords":"","body":"模型 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/d.部署.html":{"url":"question/NLP/d.部署.html","title":"d.部署问题","keywords":"","body":"部署 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/e.优化.html":{"url":"question/NLP/e.优化.html","title":"e.优化问题","keywords":"","body":"优化 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/ALG/":{"url":"question/ALG/","title":"算法","keywords":"","body":"算法 数据结构 树 排序 动态规划 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/ALG/数据结构.html":{"url":"question/ALG/数据结构.html","title":"数据结构","keywords":"","body":"数据结构 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-27 "},"question/ALG/树.html":{"url":"question/ALG/树.html","title":"树","keywords":"","body":"树 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-27 "},"question/ALG/排序.html":{"url":"question/ALG/排序.html","title":"排序","keywords":"","body":"常用排序 快速排序：O(NlogN) O(logN) 基本思想: 选出一个数，不断切分成大、小数组。 过程: 从数组中取出一个数：key 将比key小的置左，将比key大的置后 对左右两个小数组重复步骤二，直到小数组无法再分 复杂度：时间O(NlogN) 空间O(logN) 代码: # 快排写法 def quicksort(arr, low, high): if low arr[0]] return quick_sort(l) + [arr[0]] + quick_sort(r) # lambda一行写法 q_sort = lambda x: [] if len(x) == 0 else \\ q_sort([s for s in x[1:] if s x[0]]) 插入排序：O(N²) O(1) 基本思想：构建有序序列，将未排序的数据，在已排序的序列中从后向前扫描，插入到相应位置。 过程： 假设第一个数位置已排序好 从第二个数开始与前面的比较，小数前移，不断优化前置的顺序数列 复杂度：时间O(N²) 空间O(1) 代码： # 插入 def insertionSort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key 冒泡排序：O(N²) O(1) 基本思想：比较相邻两个数的大小，较大的下沉，较小的前置 过程： 比较两个数，若后面的数小，交换位置（小数前置/大数后置） 两两比较，一直到比较最前的两个数。最终最小的数交换到起始位置 重复执行，将2、3...n-1个最小数排列成功。 优化：设置一个状态，若某轮检索，没有交换任何元素，说明已经排好，直接停止。 复杂度：时间O(N²) 空间O(1) 代码：def bouble_sort(arr: List[int]): l = len(arr) - 1 flag = True # 优化点 i = j = 0 while i arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] flag = False j += 1 if flag: break i += 1 return arr 堆排序：O(NlogN) O(1) 基本思想：利用堆积构建完全二叉树。 过程：（具体步骤需要深入理解） 将列表堆化（完全二叉树）父节点值 > 左右节点值 交换头尾元素后，摘出最大值，破坏堆积后重新进行堆化 依次交换优化堆积后，列表排序成功 复杂度：时间O(NlogN) 空间O(1) 代码： # 堆排序 def heap_sort(tree: List[int]): n = len(tree) # 根据列表，反向构建完全二叉树的堆积 for i in range(n, -1, -1): heapify(tree, n, i) # 依次交换尾、头元素，交换导致破坏堆结构后，再次优化堆积 for i in range(n - 1, 0, -1): tree[i], tree[0] = tree[0], tree[i] heapify(tree, i, 0) return tree # 堆化 def heapify(tree: List[int], n, i): if i >= n: return # 列表堆化的三角节点与索引关系：i父节点p=(i-1)/2 左孩子l=2i+1 右孩子r=2i+2 l = 2 * i + 1 r = 2 * i + 2 max = i # 设法找到最大值 if l tree[i]: max = l if r tree[max]: max = r if max != i: # 找到max后，若max不是原父节点i，交换一下，重新堆化 tree[i], tree[max] = tree[max], tree[i] heapify(tree, n, max) Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-27 "},"question/ALG/动态规划.html":{"url":"question/ALG/动态规划.html","title":"动态规划","keywords":"","body":"动态规划 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-27 "},"question/Linux/":{"url":"question/Linux/","title":"Linux","keywords":"","body":"Linux Linux系统 - CentOS - Ubuntu - Redhat 基本命令 命令 说明 ls 查看当前目录信息 tree 以树状方式显示目录信息 pwd 查看当前目录路径 clear 清除终端内容 cd 目录 切换到指定目录 cd ~ 切换到当前用户的主目录 cd .. 切换到上一级目录 cd . 切换到当前目录 cd - 切换到上一次目录 touch 文件名 创建指定文件 mkdir 目录名 创建目录(文件夹) rm 文件名或者目录名 删除指定文件或者目录 rmdir 目录名 删除空目录 cp 拷贝文件、拷贝目录(-r) [cp 源 目标] mv 移动文件、移动目录、重命名 [mv 源 目标] > 若文件存在会覆盖原有文件内容，‘w’模式 >> 若文件存在会追加写入文件末尾，‘a’ 模式 cat 查看小型文件 more 分屏查看大型文件 ln 创建硬链接 ln -s 创建软链接 [ln -s 源路径(绝对路径) 软链接] grep 文本搜索 grep -i 忽略大小写 grep '^a' 以字符串a开头 grep 'a$' 以字符串a结尾 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "}}