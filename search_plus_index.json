{"./":{"url":"./","title":"主页","keywords":"","body":"ZBook Python NLP 算法 Linux 数据库 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-29 "},"question/Py/":{"url":"question/Py/","title":"Python","keywords":"","body":"Python 常见的理论知识点与问题 Python基本数据类型 不可变类型： int/float/bool/complex(复数) str '' tuple () 可变类型： list [] dict {} set set() 匿名函数 没有名字的函数 语法：lambda [形参1],[形参2],...:[单行表达式]/[函数调用] 列表推导式 语法：[x for x in range(1,101)] 命名空间 一个命名系统，可以理解为一个作用域里不可以有两个一模一样的实体，确保唯一性，避免命名冲突。 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/":{"url":"question/NLP/","title":"NLP","keywords":"","body":"NLP 常见的理论知识点与问题 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/a.理论.html":{"url":"question/NLP/a.理论.html","title":"a.理论问题","keywords":"","body":"理论 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/b.数据.html":{"url":"question/NLP/b.数据.html","title":"b.数据问题","keywords":"","body":"数据 文本预处理 基本处理方法 分词 jieba（自定义词典） 全模式 精确模式 搜索引擎模式 词性标注（POS） hanlp 命名实体识别（NER） hanlp 张量表示 one-hot 操作简单 完全割裂词与词之间的联系，且预料越大引发维度灾难 word2vec 训练模式 CBOW 上下文词汇预测目标词 Skipgram 目标词预测上下文词汇 工具：fastText model = fasttext.train_unsupervised('datafile')# 无监督训练词向量 model.get_word_vector(\"word\")# 获取word词向量 word Embedding(词嵌入) 将词汇映射到指定维度空间 广义：所有密集词汇向量 狭义：神经网络中的embedding层（embedding矩阵：训练中所有输入词汇的向量组成的矩阵） 文本语料数据分析 标签数量分布 句子长度分布 词频统计与关键词词云 文本特征 n-gram特征 文本长度规范 数据增强 回译增强 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/c.模型.html":{"url":"question/NLP/c.模型.html","title":"c.模型问题","keywords":"","body":"模型 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/d.部署.html":{"url":"question/NLP/d.部署.html","title":"d.部署问题","keywords":"","body":"部署 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/NLP/e.优化.html":{"url":"question/NLP/e.优化.html","title":"e.优化问题","keywords":"","body":"优化 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/ALG/":{"url":"question/ALG/","title":"算法","keywords":"","body":"算法 数据结构 树 排序 动态规划 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/ALG/数据结构.html":{"url":"question/ALG/数据结构.html","title":"数据结构","keywords":"","body":"数据结构 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-27 "},"question/ALG/树.html":{"url":"question/ALG/树.html","title":"树","keywords":"","body":"树 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-27 "},"question/ALG/查找.html":{"url":"question/ALG/查找.html","title":"查找","keywords":"","body":"查找 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-29 "},"question/ALG/排序.html":{"url":"question/ALG/排序.html","title":"排序","keywords":"","body":"常用排序 快速排序：O(NlogN) O(logN) 基本思想: 选出一个数，不断切分成大、小数组。 过程: 从数组中取出一个数：key 将比key小的置左，将比key大的置后 对左右两个小数组重复步骤二，直到小数组无法再分 复杂度：时间O(NlogN) 空间O(logN) 代码: # 快排写法 def quicksort(arr, low, high): if low arr[0]] return quick_sort(l) + [arr[0]] + quick_sort(r) # lambda一行写法 q_sort = lambda x: [] if len(x) == 0 else \\ q_sort([s for s in x[1:] if s x[0]]) 插入排序：O(N²) O(1) 基本思想：构建有序序列，将未排序的数据，在已排序的序列中从后向前扫描，插入到相应位置。 过程： 假设第一个数位置已排序好 从第二个数开始与前面的比较，小数前移，不断优化前置的顺序数列 复杂度：时间O(N²) 空间O(1) 代码： # 插入 def insertionSort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key 冒泡排序：O(N²) O(1) 基本思想：比较相邻两个数的大小，较大的下沉，较小的前置 过程： 比较两个数，若后面的数小，交换位置（小数前置/大数后置） 两两比较，一直到比较最前的两个数。最终最小的数交换到起始位置 重复执行，将2、3...n-1个最小数排列成功。 优化：设置一个状态，若某轮检索，没有交换任何元素，说明已经排好，直接停止。 复杂度：时间O(N²) 空间O(1) 代码：def bouble_sort(arr: List[int]): l = len(arr) - 1 flag = True # 优化点 i = j = 0 while i arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] flag = False j += 1 if flag: break i += 1 return arr 堆排序：O(NlogN) O(1) 基本思想：利用堆积构建完全二叉树。 过程：（具体步骤需要深入理解） 将列表堆化（完全二叉树）父节点值 > 左右节点值 交换头尾元素后，摘出最大值，破坏堆积后重新进行堆化 依次交换优化堆积后，列表排序成功 复杂度：时间O(NlogN) 空间O(1) 代码： # 堆排序 def heap_sort(tree: List[int]): n = len(tree) # 根据列表，反向构建完全二叉树的堆积 for i in range(n, -1, -1): heapify(tree, n, i) # 依次交换尾、头元素，交换导致破坏堆结构后，再次优化堆积 for i in range(n - 1, 0, -1): tree[i], tree[0] = tree[0], tree[i] heapify(tree, i, 0) return tree # 堆化 def heapify(tree: List[int], n, i): if i >= n: return # 列表堆化的三角节点与索引关系：i父节点p=(i-1)/2 左孩子l=2i+1 右孩子r=2i+2 l = 2 * i + 1 r = 2 * i + 2 max = i # 设法找到最大值 if l tree[i]: max = l if r tree[max]: max = r if max != i: # 找到max后，若max不是原父节点i，交换一下，重新堆化 tree[i], tree[max] = tree[max], tree[i] heapify(tree, n, max) Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-27 "},"question/ALG/动态规划.html":{"url":"question/ALG/动态规划.html","title":"动态规划","keywords":"","body":"动态规划 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-27 "},"question/Linux/":{"url":"question/Linux/","title":"Linux","keywords":"","body":"Linux Linux内核操作系统：CentOS、Ubuntu、Redhat 常用命令 进程线程协程 Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/Linux/Linux命令.html":{"url":"question/Linux/Linux命令.html","title":"常用命令","keywords":"","body":"Linux命令 常用命令 命令 说明 示例 文件操作 cp 复制 cp a.txt b.txt // cp -r a b mv 移动/修改文件 mv f1 /dir rm -rf 经典的删档入狱指令,谨慎使用 head 从头部打印查看文件 head 1.log -n 5 // head -n -5 t.log tail 从尾部打印查看文件 tail 1.log -n 5 which 执行命令的文件位置 echo $PATH 查看当前 PATH 配置 chmod 修改权限 r:4 w:2 x:1 chmod 751 file find 查找文件 -name -atime -size find . -name '*.log' 压缩/解压 gzip 压:tar -zcvf filename.tar.gz [file/path] 解:tar zxvf filename.tar.gz bz2 压:tar -jcvf filename.tar.bz2 [file/path] 解:tar jxvf filename.tar.bz2 zip 压:zip -q -r file.zip [file/path] 解:unzip file.zip 硬件 free 内存情况 -k:KB -m:MB -g:GB -s:持续查询 free -s 10(间隔十秒查询) du 查看文件及大小 -k:KB -m:MB -g:GB du -mh df -l 硬盘空间 ln -s:软连接 -b:覆盖以前的链接 ln a ../a // ln -s a.log ../b.log 任务进程 PID 查看任务PID ps -ef | grep python // pgrep -f python jobs 查看后台任务%ID kill 终止进程 kill -9 PID // $jobs $kill -9 %jobID pkill 终止进程(程序名) pkill -f name lsof 端口占用 lsof -i:[端口号] Ctrl+Z 停止 Ctrl+C 挂起 其他操作 步骤一 步骤二 CentOS系统时间 rm -rf /etc/localtime ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 基本命令 命令 说明 ls [选项] 查看目录文件 [-a 隐藏文件] tree 以树状方式显示目录信息 pwd 查看当前目录路径 clear 清除终端内容 cd [目录] 切换目录 cd ~ 切换到当前用户的主目录 cd .. 切换到上一级目录 cd . 切换到当前目录 cd - 切换到上一次目录 touch 文件名 创建指定文件 mkdir [!文件夹名] 创建文件夹 [-p 不存在则创建] rm [选项] [文件] 删除文件/目录 [-r 递归] rmdir 目录名 删除空目录 cp 拷贝文件、拷贝目录(-r) [cp 源 目标] mv 移动文件、移动目录、重命名 [mv 源 目标] > 若文件存在会覆盖原有文件内容，‘w’模式 >> 若文件存在会追加写入文件末尾，‘a’ 模式 cat 查看小文件 cat > file 写文件 cat >file.txt content >EOF cat file1 file2 > file 合并文件 cat f1 // cat > f1 // cat f1 f2 > f3 more 分屏查看大型文件 ln 创建硬链接 ln -s 创建软链接 [ln -s 源路径(绝对路径) 软链接] grep 文本搜索 grep -i 忽略大小写 grep '^a' 以字符串a开头 grep 'a$' 以字符串a结尾 find 指定目录下查找文件(包括目录) find -name 文件名(包括目录名)查找 zip 压缩.zip格式文件 unzip 解压.zip格式文件[unzip -d 解压至指定目录] Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "},"question/Linux/进程线程协程.html":{"url":"question/Linux/进程线程协程.html","title":"进程线程协程","keywords":"","body":"进程 & 线程 & 协程 进程 进程是操作系统进行资源分配的基本单位。 一个程序运行后至少有一个进程，一个进程默认有一个线程 import multiprocessing def task(): for i in range(10): print(\"任务执行中...\") time.sleep(0.2) sub_process = multiprocessing.Process(target=task, kwargs={\"count\": 3}) sub_process.daemon = True sub_process.start() Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-29 "},"question/DATA/":{"url":"question/DATA/","title":"数据库","keywords":"","body":"Database MySQL Neo4j Redis MongoDB Just to learning. For infringement, please contact deleted. Copyright © 2021 zbmain.本页修订时间： 2021-03-28 "}}