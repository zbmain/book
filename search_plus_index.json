{"./":{"url":"./","title":"主页","keywords":"","body":"ZBook 个人总结: Python ML NLP Linux 算法 数据库 Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-04-13 "},"question/Py/":{"url":"question/Py/","title":"Python","keywords":"","body":"Python 常见的理论知识点与问题 Python基本数据类型 不可变类型： int/float/bool/complex(复数) str '' tuple () 可变类型： list [] dict {} set set() 匿名函数 没有名字的函数 语法：lambda [形参1],[形参2],...:[单行表达式]/[函数调用] 列表推导式 语法：[x for x in range(1,101)] 命名空间 一个命名系统，可以理解为一个作用域里不可以有两个一模一样的实体，确保唯一性，避免命名冲突。 Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-03-28 "},"question/Py/Python util_func.html":{"url":"question/Py/Python util_func.html","title":"Util func","keywords":"","body":"字符串数组 互转 字符串 -> 数组 x = '123' list(x) # ['1', '2', '3'] x = '1,2,3' x.split(',') # ['1', '2', '3'] 数组 -> 字符串 arr = ['a','b','c'] x = ''.join(arr) x = ','.join(arr) arr = [1,2,3] x = ','.join(str(i) for i in arr) # 使用遍历强转元素格式 x = ''.join(arr) # 若列表中有数字类型，使用join(arr)报错 字符串 -> 整型数组 x = '1 2 3' #有时候通过input输入 print(x.split()) # 元素类型为str:['1','2','3'] print(list(map(int, x.split()))) # 将字符串转数组元素类型改为int:[1,2,3] 最大值 # 整数 import sys MAX_INT = sys.maxsize # 浮点数 MAX_FLOAT = float('inf') # float('-inf') Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-04-12 "},"question/ML/":{"url":"question/ML/","title":"ML","keywords":"","body":"机器学习 无监督学习 关联规则：发生不同事物之间的关系。在数据库的候选项集中用来挖掘出现频繁的项集，并发现他们之间的关联规则。 Apriori算法 聚类问题：相似样本划分为一个簇，与分类问题不同点：聚类预先并不知道类别。 K-means算法 降维：减少数据的维度同时保证不丢失有意义的信息。（通过特征提取、特征选择） PCA(主成分分析) Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-03-31 "},"question/NLP/":{"url":"question/NLP/","title":"NLP","keywords":"","body":"NLP 理论 数据 模型 部署 优化 Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-04-09 "},"question/NLP/a.理论.html":{"url":"question/NLP/a.理论.html","title":"a.理论问题","keywords":"","body":"理论 Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-04-02 "},"question/NLP/b.数据.html":{"url":"question/NLP/b.数据.html","title":"b.数据问题","keywords":"","body":"数据 文本预处理 基本处理方法 分词 jieba（自定义词典） 全模式 精确模式 搜索引擎模式 词性标注（POS） hanlp 命名实体识别（NER） hanlp 张量表示 one-hot 操作简单 完全割裂词与词之间的联系，且预料越大引发维度灾难 word2vec 训练模式 CBOW 上下文词汇预测目标词 Skipgram 目标词预测上下文词汇 工具：fastText model = fasttext.train_unsupervised('datafile')# 无监督训练词向量 model.get_word_vector(\"word\")# 获取word词向量 word Embedding(词嵌入) 将词汇映射到指定维度空间 广义：所有密集词汇向量 狭义：神经网络中的embedding层（embedding矩阵：训练中所有输入词汇的向量组成的矩阵） 文本语料数据分析 标签数量分布 句子长度分布 词频统计与关键词词云 文本特征 n-gram特征 文本长度规范 数据增强 回译增强 Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-03-28 "},"question/NLP/c.模型.html":{"url":"question/NLP/c.模型.html","title":"c.模型问题","keywords":"","body":"模型 Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-03-28 "},"question/NLP/d.部署.html":{"url":"question/NLP/d.部署.html","title":"d.部署问题","keywords":"","body":"部署 Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-03-28 "},"question/NLP/e.优化.html":{"url":"question/NLP/e.优化.html","title":"e.优化问题","keywords":"","body":"优化 Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-03-28 "},"question/Linux/":{"url":"question/Linux/","title":"Linux","keywords":"","body":"Linux Linux内核操作系统：CentOS、Ubuntu、Redhat 常用命令 进程线程协程 Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-03-28 "},"question/Linux/Linux命令.html":{"url":"question/Linux/Linux命令.html","title":"常用命令","keywords":"","body":"Linux命令 常用命令 命令 说明 示例 文件操作 cp 复制 cp a.txt b.txt // cp -r a b mv 移动/修改文件 mv f1 /dir rm -rf 经典的删档入狱指令,谨慎使用 head 从头部打印查看文件 head 1.log -n 5 // head -n -5 t.log tail 从尾部打印查看文件 tail 1.log -n 5 which 执行命令的文件位置 echo $PATH 查看当前 PATH 配置 chmod 修改权限 r:4 w:2 x:1 chmod 751 file find 查找文件 -name -atime -size find . -name '*.log' 压缩/解压 gzip 压:tar -zcvf filename.tar.gz [file/path] 解:tar zxvf filename.tar.gz bz2 压:tar -jcvf filename.tar.bz2 [file/path] 解:tar jxvf filename.tar.bz2 zip 压:zip -q -r file.zip [file/path] 解:unzip file.zip 硬件 free 内存情况 -k:KB -m:MB -g:GB -s:持续查询 free -s 10(间隔十秒查询) du 查看文件及大小 -k:KB -m:MB -g:GB du -mh df -l 硬盘空间 ln -s:软连接 -b:覆盖以前的链接 ln a ../a // ln -s a.log ../b.log 任务进程 PID 查看任务PID ps -ef | grep python // pgrep -f python jobs 查看后台任务%ID kill 终止进程 kill -9 PID // $jobs $kill -9 %jobID pkill 终止进程(程序名) pkill -f name lsof 端口占用 lsof -i:[端口号] Ctrl+Z 停止 Ctrl+C 挂起 其他操作 步骤一 步骤二 CentOS系统时间 rm -rf /etc/localtime ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 基本命令 命令 说明 ls [选项] 查看目录文件 [-a 隐藏文件] tree 以树状方式显示目录信息 pwd 查看当前目录路径 clear 清除终端内容 cd [目录] 切换目录 cd ~ 切换到当前用户的主目录 cd .. 切换到上一级目录 cd . 切换到当前目录 cd - 切换到上一次目录 touch 文件名 创建指定文件 mkdir [!文件夹名] 创建文件夹 [-p 不存在则创建] rm [选项] [文件] 删除文件/目录 [-r 递归] rmdir 目录名 删除空目录 cp 拷贝文件、拷贝目录(-r) [cp 源 目标] mv 移动文件、移动目录、重命名 [mv 源 目标] > 若文件存在会覆盖原有文件内容，‘w’模式 >> 若文件存在会追加写入文件末尾，‘a’ 模式 cat 查看小文件 cat > file 写文件 cat >file.txt content >EOF cat file1 file2 > file 合并文件 cat f1 // cat > f1 // cat f1 f2 > f3 more 分屏查看大型文件 ln 创建硬链接 ln -s 创建软链接 [ln -s 源路径(绝对路径) 软链接] grep 文本搜索 grep -i 忽略大小写 grep '^a' 以字符串a开头 grep 'a$' 以字符串a结尾 find 指定目录下查找文件(包括目录) find -name 文件名(包括目录名)查找 zip 压缩.zip格式文件 unzip 解压.zip格式文件[unzip -d 解压至指定目录] Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-03-28 "},"question/Linux/进程线程协程.html":{"url":"question/Linux/进程线程协程.html","title":"进程线程协程","keywords":"","body":"进程 & 线程 & 协程 进程 进程是操作系统进行资源分配的基本单位。 一个程序运行后至少有一个进程，一个进程默认有一个线程 import multiprocessing def task(): for i in range(10): print(\"任务执行中...\") time.sleep(0.2) sub_process = multiprocessing.Process(target=task, kwargs={\"count\": 3}) sub_process.daemon = True sub_process.start() Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-03-29 "},"question/ALG/":{"url":"question/ALG/","title":"算法","keywords":"","body":"算法 树链 排序 动态规划 常见算法 业务题例 Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-04-10 "},"question/ALG/树链.html":{"url":"question/ALG/树链.html","title":"树链","keywords":"","body":"创建二叉树、前中后序/深度/广度遍历 class TreeNode(object): def __init__(self, val, l=None, r=None): self.val = val self.lchild = l self.rchild = r class Tree(object): def __init__(self, root=None): if not isinstance(root, TreeNode): root = TreeNode(root) self.root = root def add(self, node): if not isinstance(node, TreeNode): node = TreeNode(node) # root为None的情况 if self.root == None: self.root = node return self queue = [self.root] while queue: cur_node = queue.pop(0) if not cur_node.lchild: cur_node.lchild = node return self else: queue.append(cur_node.lchild) if not cur_node.rchild: cur_node.rchild = node return self else: queue.append(cur_node.rchild) # 广度遍历 def breadth_travel(self): if self.root is None: return queue = [self.root] while queue: cur_node = queue.pop(0) # 从root开始 print(cur_node.val) if cur_node.lchild: # 该节点的左 queue.append(cur_node.lchild) if cur_node.rchild: # 该节点的右 queue.append(cur_node.rchild) # 深度遍历，同样的代码递归流程。三个环节位置 -> 三种遍历方式（获取值） # 1.前序遍历（先遍历树节点，然后遍历左节点，再遍历右节点） def preorder(self, node: TreeNode): if not node: return print(node.val) # 父节点：root开始 self.preorder(node.lchild) # 开始挖左 self.preorder(node.rchild) # 最左挖到叶子节点，才来到此行挖右 # 2.中序遍历（先遍历左节点，然后遍历父节点，再遍历右节点） def inorder(self, node: TreeNode): if not node: return self.inorder(node.lchild) # print(node.val) self.inorder(node.rchild) # 进入右节点 # 3.后序遍历 def protorder(self, node: TreeNode): if not node: return self.protorder(node.lchild) self.protorder(node.rchild) print(node.val) # 关键点 # 深度遍历 def dfs(node): def _dfs(node): if node is None: return print(node.val) _dfs(node.lchild) _dfs(node.rchild) _dfs(node.root) # 广度遍历 def bfs(node): if node.root is None: return queue = [node.root] while queue: cur_node = queue.pop(0) # 从root开始 print(cur_node.val) # 获取到的值 if cur_node.lchild: # 该节点的左 queue.append(cur_node.lchild) if cur_node.rchild: # 该节点的右 queue.append(cur_node.rchild) # UT tree = Tree(0).add(1).add(2).add(3).add(4).add(5).add(6).add(7).add(8).add(9) print('前序遍历') tree.preorder(tree.root) print('中序遍历') tree.inorder(tree.root) print('后序遍历') tree.protorder(tree.root) print('深度遍历') dfs(tree) print('广度遍历') bfs(tree) 是否为相同树 class TreeNode(object): def __init__(self, val, l=None, r=None): self.val = val self.left = l self.right = r class Solution: # 深度遍历法 def isSameTree(self, p: TreeNode, q: TreeNode) -> bool: # 全部同时为空，则一模一样 if not p and not q: return True # 只有一个为空，则不一样 elif not p or not q: return False # 如果节点值不一样，则不一样 elif p.val != q.val: return False else: # 深度遍历代码 return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) # UT tree1 = TreeNode(1,TreeNode(2,TreeNode(4),TreeNode(5),),TreeNode(3,TreeNode(6),TreeNode(7))) tree2 = TreeNode(1,TreeNode(2,TreeNode(4),TreeNode(5),),TreeNode(3,TreeNode(6),TreeNode(7))) tree3 = TreeNode(1,TreeNode(2,TreeNode(3),TreeNode(4),),TreeNode(5,TreeNode(6),TreeNode(7))) print(Solution().isSameTree(tree1,tree2)) # True print(Solution().isSameTree(tree1,tree3)) # False 翻转二叉树 # 翻转二叉树（交换左右节点） def invertTree(root: TreeNode) -> TreeNode: return None if not root else TreeNode(root.val, invertTree(root.rchild), invertTree(root.lchild)) # 翻转树 invert_tree = invertTree(tree.root) 打印链表 from typing import List class ListNode(): def __init__(self, val, next=None): self.val = val self.next = next class Solution: # 反转链表 def reverseList(head: ListNode) -> ListNode: last = None while head: head.next, last, head = last, head, head.next return last # 顺序打印链表 def printList(self,head: ListNode) -> List[int]: res = [] while head: res.append(head.val) head = head.next return res # UT lst = ListNode(0,ListNode(1,ListNode(2,ListNode(3,ListNode(4))))) print(Solution().printList(lst)) # 顺打印 print(Solution().printList(lst)[::-1]) # 反向打印 删除排序链表中的重复元素 class ListNode(): def __init__(self, val, next=None): self.val = val self.next = next def delDuplicates(head: ListNode) -> ListNode: node = head while node and node.next: if node.val == node.next.val: node.next = node.next.next else: node = node.next return head 合并二个有序链表 class ListNode(): def __init__(self, val, next=None): self.val = val self.next = next # 方法一：递归 O(N+M)O(N+M) def mergeList(l1: ListNode, l2: ListNode): if not l1: return l2 if not l2: return l1 if l1.val 二叉树中最近的公共父节点 class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def lowestCommonAncestor(root, p, q): if not root: return root if root.val == p.val or root.val == q.val: return root l = self.lowestCommonAncestor(root.left, p, q) r = self.lowestCommonAncestor(root.right, p, q) if l and r: return root if l: return l if r: return r Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-04-17 "},"question/ALG/查找.html":{"url":"question/ALG/查找.html","title":"查找","keywords":"","body":"顺序查找：O(N) O(1) from typing import List def seq_search(nums:List[int],n): for i,v in nums: if n == v: return i return -1 二分查找一维数组 from typing import List def b_search(nums:List[int],X): def binarySearch(arr, l, r, x): if l x: return binarySearch(arr, l, mid-1, x) while else: return mid else: return -1 return binarySearch(nums,0,len(nums)-1,X) # 测试代码 arr = [1,5,8,9] X = 8 print(b_search(arr,X)) 二分查找二维数组 from typing import List class Solution: # 二分查找 def binarySearch2D(self, nums: List[List[int]], target: int) -> bool: if not nums or len(nums) == 0 or not nums[0] or len(nums[0]) == 0: return False m, n = len(nums), len(nums[0]) i, j = 0, n - 1 while (i = 0): if target nums[i][j]: i += 1 else: return True return False 找出只出现一次的元素 from functools import reduce from typing import List import random class Solution: def singleNumber(self, nums: List[int]) -> int: return reduce(lambda x, y: x ^ y, nums) #测试代码 lst = [i for i in range(101)] lst.extend(lst);lst.remove(20);random.shuffle(lst) print(Solution().singleNumber(lst)) 找出重复出现的元素 from typing import List import random class Solution: # 1.异或法:O(N) O(1) 需要前提条件 # 异或法控制了空间复杂度O(1) # 1-100的数，放在101位数组中，多出的一位是重复元素，找出该元素。A^A^B = B # 此方法全部计算后才能得到结果，而其他方法可以在中途找到直接return # 重要条件:因为所有的B都必须异或一次，所以要求1-100的数字都必须出现 def findRepeatNumber(self,nums: List[int]) -> int: tmp = nums[0] for i in enumerate(nums[1:]): tmp ^= (i[0] ^ i[1]) return tmp # 2.下标定位之元素交换法:O(N)O(1) # 数组元素交换控制了空间复杂度O(1) # 但是也导致了前提条件：数组中元素的最大值必须小于数组的长度。(MAX int: for i,v in enumerate(nums): if v != i: if nums[v] == v: return v nums[v] , nums[i] = v , nums[v] return -1 # 3.哈希表中介法:O(N)O(N) def findRepeatNumber3(self,nums:List[int]) -> int: _dict = {} for v in nums: if v in _dict: return v _dict[v] = '' return -1 # 4.排序判断法:O(NlogN)O(1) def findRepeatNumber4(self, nums): nums.sort() pre = nums[0] for index in range(1, len(nums)): if pre == nums[index]: return pre pre = nums[index] # 测试代码 lst = [i for i in range(101)] lst.append(10);random.shuffle(lst) print(Solution().findRepeatNumber(lst)) print(Solution().findRepeatNumber2(lst)) print(Solution().findRepeatNumber3(lst)) print(Solution().findRepeatNumber4(lst)) 有序数组中最小数 from typing import List class Solution: def minArray(self, numbers: List[int]) -> int: left, right = 0, len(numbers) - 1 while left numbers[right]: left = mid + 1 elif numbers[mid] 相邻元素之后最大(最小)的元素序号 import sys import random from typing import List def search_near_diff(nums:List[tuple]): pre, max_diff, max_idx= nums[0][1], 0, 0 # 最大 # pre, max_diff, max_idx= nums[0][1],sys.maxsize , 0 # 最小 for idx,_ in enumerate(nums[1:]): tmp = abs(_[1] - pre) if max_diff tmp: # 最小 max_diff, max_idx = tmp, idx pre = _[1] return nums[max_idx][0],nums[max_idx+1][0] # 测试代码 NUM, MAX = 5, 100 lands = [(i,random.randint(0,MAX)) for i in range(1,NUM+1)] print(lands) print(search_near_max_diff(lands)) 最长公共前缀 from typing import List def longestCommonPrefix(strs: List[str]) -> str: ans = '' for i in zip(*strs): # 去重后等于1，说明三个列字符一样 if len(set(i)) == 1: ans += i[0] else: break return ans cmn = longestCommonPrefix(['ab', 'abc', 'abcd']) print(cmn) 两数之和(数组中两元素和为某数的所有组合) from typing import List class Solttion: # O(N) 哈希键存储 def sum(self, nums: List[int], target: int) -> List[int]: hash = {} for i, num in enumerate(nums): if target - num in hash: return (hash[target - num], i) hash[nums[i]] = i return () # 暴力 O(NN) def sum2(self, nums: List[int], target: int) -> List[int]: for _,i in enumerate(nums): for __,j in enumerate(nums[_:]): if i+j == target: return _,_+__ # O(N) print(Solttion().sum([1,5,6,8],9)) # O(n*n) print(Solttion().sum2([1,5,6,8],9)) 3数/N数之和(数组中N个元素和为某数的所有组合) from typing import List class Solution: def threeSum(self, nums: List[int]) -> List[List[int]]: # 解决nSum问题 if len(nums) target: right -= 1 else: left += 1 return res else: for first_idx in range(len(nums)): if first_idx > 0 and nums[first_idx] == nums[first_idx-1]: continue subres = self.nSum(nums[first_idx+1:], n-1, target-nums[first_idx]) for i in range(len(subres)): res.append([nums[first_idx]]+subres[i]) return res def threeSum2(self, nums: List[int]) -> List[List[int]]: \"\"\"三数之和，暴力列举的话，时间复杂度为O(n^3)，该解法为O(n^2)\"\"\" # 因为是计算三数之和，因此输入数组的长度必须大于等于3，否则返回[] # 因此首先进行长度判断 n = len(nums) if n 0则之后不需要再进行判断，直接返回结果即可 if nums[i] > 0: return res # 因为题目要求，不需要重复答案，因此如果nums[i]与之前相同则跳过 # 这里注意不能从第一个开始跳过的，因为[0, 0, 0]都跳过变成[] if(i>0 and nums[i]==nums[i-1]): continue # 好，这些特殊情况处理之后，我们定义双指针 # left从当前索引的下一个索引开始 L = i+1 # right从最后一个索引开始 R = n-1 # 双指针结束条件为L 0): R -= 1 # 否则移动左指针 else: L += 1 return res # UT lst = [-1,0,1,2,-1,-4,8,-6,-2] lst.sort() print(Solution().nSum(lst,4,0)) 组合总数(列表中元素和为某数的所有组合) from typing import List class Solution: def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]: candidates = sorted(candidates) ans = [] def find(s, use, remain): for i in range(s, len(candidates)): c = candidates[i] if c == remain: ans.append(use + [c]) if c remain: return find(0, [], target) return ans def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]: dp = [[] for _ in range(target+1)] for i in sorted(candidates,reverse=True): for j in range(i,target+1): if j==i:dp[j] = [[i]];continue dp[j].extend([x+[i] for x in dp[j-i]]) # print(dp) return dp[-1] def combinationSum3(self, candidates: List[int], target: int) -> List[List[int]]: dict = {} for i in range(1,target+1): dict[i]=[] for i in range(1,target+1): for j in candidates: if i==j: dict[i].append([i]) elif i>j: for k in dict[i-j]: x = k[:] x.append(j) x.sort() # 升序，便于后续去重 if x not in dict[i]: dict[i].append(x) return dict[target] # 测试代码 print(len(Solution().combinationSum([1,2,3,4],5))) print(len(Solution().combinationSum2([1,2,3,4],5))) print(len(Solution().combinationSum3([1,2,3,4],5))) Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-04-10 "},"question/ALG/排序.html":{"url":"question/ALG/排序.html","title":"排序","keywords":"","body":"哈希排序：O(N) O(1) 基本思想：利用桶概念哈希排序，将数组中的值映射到有限的O(1)数值表中.类型：TF-IDF 前提：桶的个数必须大于排序数组中最大值，可以自定义，也可以用max()获取 过程： 生成一个有限的数值映射数组 遍历排序数组，将其在映射数组中的频次+1 遍历映射数组，将所有位置的数值放入原数组中（为了不增加空间复杂度），放入次数=频次 说明： 传说中的时间复杂度O(N)排序。因为桶被当成了常量，严格可以看作：O（N+MAX） 空间复杂度O(1)。因为映射表长度也被看作常量，严格可以看作：O(MAX) 代码：from typing import List # 长度必须大于数组中最大值 MAX = 65535 def hash_sort(nums:List[int]): MAX = max(nums)+1 lst = MAX * [0] for i in nums: lst[i] += 1 index = 0 for i in enumerate(lst): for j in range(i[1]): nums[index] = i[0] index += 1 return nums 桶排序：O(N+K) O(n*k) 基本思想：构建N个桶,将数组中放置到各区间的桶内，进行小范围排序后依次取出。 过程： 构建N各桶，N = (MAX-MIN)/len 遍历数组，数组中的数置于各区间桶中 小桶排序 取出数，合并（此处使用了sum()高级用法） 说明：因为此处的sorted是O(NlogN)，但是它是经过分类后的小范围快排，故在比较上忽略掉了。 代码： def bucket_sort(arr): max_,min_=max(arr),min(arr) stride=(max_-min_)/len(arr) buckets=[[] for i in range(len(arr)+1)] for num in arr: buckets[int((num-min_)//stride)].append(num) arr = [sorted(bucket) for bucket in buckets] return sum(arr,[])# sum高级用法，加和从[]开始（二维数组中[]开始） print(bucket_sort([54,26,93,21,17,77,31,44,55,20])) 快速排序：O(NlogN) O(logN) 基本思想: 选出一个数，不断切分成大、小数组。 过程: 从数组中取出一个数：key 将比key小的置左，将比key大的置后 对左右两个小数组重复步骤二，直到小数组无法再分 复杂度：时间O(NlogN) 空间O(logN) 代码: # 快排写法 def quicksort(arr, low, high): if low arr[0]] return quick_sort(l) + [arr[0]] + quick_sort(r) # lambda一行写法 q_sort = lambda x: [] if len(x) == 0 else \\ q_sort([s for s in x[1:] if s x[0]]) 插入排序：O(N²) O(1) 基本思想：构建有序序列，将未排序的数据，在已排序的序列中从后向前扫描，插入到相应位置。 过程： 假设第一个数位置已排序好 从第二个数开始与前面的比较，小数前移，不断优化前置的顺序数列 复杂度：时间O(N²) 空间O(1) 代码： # 插入 def insertionSort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key 冒泡排序：O(N²) O(1) 基本思想：比较相邻两个数的大小，较大的下沉，较小的前置 过程： 比较两个数，若后面的数小，交换位置（小数前置/大数后置） 两两比较，一直到比较最前的两个数。最终最小的数交换到起始位置 重复执行，将2、3...n-1个最小数排列成功。 优化：设置一个状态，若某轮检索，没有交换任何元素，说明已经排好，直接停止。 复杂度：时间O(N²) 空间O(1) 代码：def bouble_sort(arr: List[int]): l = len(arr) - 1 flag = True # 优化点 i = j = 0 while i arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] flag = False j += 1 if flag: break i += 1 return arr 堆排序：O(NlogN) O(1) 基本思想：利用堆积构建完全二叉树。 过程：（具体步骤需要深入理解） 将列表堆化（完全二叉树）父节点值 > 左右节点值 交换头尾元素后，摘出最大值，破坏堆积后重新进行堆化 依次交换优化堆积后，列表排序成功 复杂度：时间O(NlogN) 空间O(1) 代码： # 堆排序 def heap_sort(tree: List[int]): n = len(tree) # 根据列表，反向构建完全二叉树的堆积 for i in range(n, -1, -1): heapify(tree, n, i) # 依次交换尾、头元素，交换导致破坏堆结构后，再次优化堆积 for i in range(n - 1, 0, -1): tree[i], tree[0] = tree[0], tree[i] heapify(tree, i, 0) return tree # 堆化 def heapify(tree: List[int], n, i): if i >= n: return # 列表堆化的三角节点与索引关系：i父节点p=(i-1)/2 左孩子l=2i+1 右孩子r=2i+2 l = 2 * i + 1 r = 2 * i + 2 max = i # 设法找到最大值 if l tree[i]: max = l if r tree[max]: max = r if max != i: # 找到max后，若max不是原父节点i，交换一下，重新堆化 tree[i], tree[max] = tree[max], tree[i] heapify(tree, n, max) 两个数组相对排序 from typing import List class Solution: # 方法一 sort(key) def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]: ranks = {x: i for i, x in enumerate(arr2)} arr1.sort(key=lambda x:(0,ranks[x]) if x in ranks else (1,x)) return arr1 # 方法二 计数排序法 def relativeSortArray2(self,arr1: List[int], arr2: List[int]) -> List[int]: upper = max(arr1) frequency = [0] * (upper + 1) for x in arr1: frequency[x] += 1 ans = list() for x in arr2: ans.extend([x] * frequency[x]) frequency[x] = 0 for x in range(upper + 1): if frequency[x] > 0: ans.extend([x] * frequency[x]) return ans # 通过sort()参数指定键排序 arr1,arr2 = [2,3,1,3,2,4,6,7,9,2,20,19,5,1],[2,4,3,6] print(Solution().relativeSortArray(arr1,arr2)) Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-04-10 "},"question/ALG/动态规划.html":{"url":"question/ALG/动态规划.html","title":"动态规划","keywords":"","body":"动态规划框架 核心:穷举求最值 动态规划特点: 重叠子问题 状态转移方程（最关键） 最优子结构 解题套路: 明确状态 明确选择 明确dp函数/数组的定义 明确base case DP解法代码框架: # 1.创建base case dp[0][0][...] = base # 2.初始化base case # 3.穷举状态 for 状态1 in 状态1的所有取值: for 状态2 in 状态2的所有取值: for ... # 4.状态转移 dp[状态1][状态2][...] = 求最值(选择1,选择2...) 斐波那契数 class Solution: # 最优解法：最终优化空间复杂度(% 1000000007防越界) def fib(n): i,j = 0,1 for _ in range(n): i, j = j, i + j return i % 1000000007 # 基础递归 def fib(n): if n == 0 or n == 1: return n return fib(n-1) + fib(n-2) # 递归优化 def fib(n): # 递归剪枝：将计算过的节点存起来，空间换时间 _dict = [0 for i in range(n+1)] # 递归方法 def rec(n): if n == 0 or n == 1: return n if _dict[n] != 0: return _dict[n] _dict[n] = rec(n-1) + rec(n-2) return _dict[n] return rec(n) # 动态规划（自顶向下） def fib(n): if n == 0: return 0 dp = [0 for i in range(n+1)] dp[0], dp[1] = 0, 1 for i in range(2,n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n] # 最优解法：优化空间复杂度 def fib(n): i,j = 0,1 for _ in range(n): i, j = j, i + j return i # UT print(Solution().fib(7)) 青蛙台阶 # 一次可以跳1阶/2阶 class Solution: def numWays(self, n: int) -> int: a, b = 1, 1 for _ in range(n): a, b = b, a + b return a % 1000000007 最长公共子串 def longestCommonString(self, A: str, B: str) -> int: # 因为需要遍历字符串并构建存储矩阵，所以需要求两个字符串的长度 m, n = len(A), len(B) # 初始化为0的存储矩阵，dp[i][j]用于存储该‘单元’之前的子串长度 dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # 初始化最终结果，长度为整型，默认为0 ans = 0 # 因为需要判断子问题，所以i，j以1而不是0开始，结束也是对应的m+1和n+1 # （实质遍历的是存储单元，与字符串遍历相差为1） # 对于字符串，m+1，n+1指针是越界的，但是对于存储，是不越界的。 for i in range(1, m + 1): for j in range(1, n + 1): # 通过子问题判断，来决定当前的d[i][j]的值 # d[i][j]存储的就是之间累加的子串长度 if A[i - 1] == B[j - 1]: # 如果两个字符串的当前字符相等，那么dp[i][j]的值就是之前d[i-1][j-1]存储的长度+1 dp[i][j] = dp[i - 1][j - 1] + 1 # 新得到的最长序列要和上一次得到的最长序列结果ans取最大成为新的ans ans = max(ans, dp[i][j]) # 此处不需要else：与公共子序列相比不需要考虑字符不相同的情况，不相同直接从0计数 return ans # UT a, b = 'abcdef','abf' print(longestCommonString(a, b)) - 与子序列相比，子串只是不去考虑双重循环中，条件语句中的else - 因为默认矩阵为0，即如果A[i - 1] != B[j - 1]即出现不连续，那么从0开始重新计数 - 而子序列却需要从附近的存储单元来延续这个数值 最长公共子序列 def longestCommonSubsequence(a: str, b: str) -> int: m, n = len(a), len(b) dp = [[0 for _ in range(n + 1)] for __ in range(m + 1)] ans = 0 for i in range(1, m + 1): # 规划表 外层 for j in range(1, n + 1): # 规划表 内层 if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 ans = max(ans, dp[i][j]) else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return ans # UT a, b = 'abcdef','abf' print(longestCommonSubsequence(a, b)) 编辑距离 class Solution: # 方法一：递归 def edit_distance_rec(self, word1: str, word2: str) -> int: l1,l2 = len(word1),len(word2) if l1 == 0 or l2 == 0 : return max(l1,l2) if word1[l1-1] == word2[l2-1]: return self.edit_distance_rec(word1[0:-1], word2[0:-1]) else: return min([ self.edit_distance_rec(word1[:-1], word2), self.edit_distance_rec(word1, word2[:-1]), self.edit_distance_rec(word1[:-1], word2[:-1]) ]) + 1 # 方法二：动态规划 def edit_distance_dp(self, word1: str, word2: str) -> int: n = len(word1) m = len(word2) # 有一个字符串为空串 if n * m == 0: return n + m # DP 数组 D = [ [0] * (m + 1) for _ in range(n + 1)] # 边界状态初始化：base case for i in range(n + 1): D[i][0] = i for j in range(m + 1): D[0][j] = j # 计算所有 DP 值：穷举状态 for i in range(1, n + 1): for j in range(1, m + 1): left = D[i - 1][j] + 1 down = D[i][j - 1] + 1 left_down = D[i - 1][j - 1] # 状态转移 if word1[i - 1] != word2[j - 1]: left_down += 1 D[i][j] = min(left, down, left_down) return D[n][m] #UT w1,w2 = \"banbana\",\"baa\" print(Solution().edit_distance_rec(w1,w2)) print(Solution().edit_distance_dp(w1,w2)) 机器人(0,0)到(x,y)走法 # 0,0到x,y所有走法（下、右） # 1.暴力递归 def recursion(x, y): if x == 1 or y == 1: return 1 x, y = abs(x), abs(y) return recursion(x-1, y) + recursion(x, y-1) # 2.dp动态规划 def dp_func(x, y): \"\"\" dp[i][0] = 1 for i = 0,...,x-1 dp[0][j] = 1 for j = 0,...,y-1 dp[x][y] = dp[x-1][y] + dp[x][y-1] \"\"\" if x == 0 and y == 0: return 0 if x == 0 or y == 0: return 1 x, y = abs(x), abs(y) dp = [[0 for _ in range(y)] for _ in range(x)] for i in range(x): dp[i][0] = 1 for i in range(y): dp[0][i] = 1 for i in range(1, x): for j in range(1, y): dp[i][j] = dp[i][j-1] + dp[i-1][j] return dp[x-1][y-1] def dp_func2(x,y): dp = [1 for _ in range(x)] for i in range(1,x): for j in range(1,y): dp[j] += dp[j-1] return dp[y-1] print(recursion(4,4)) print(dp_func(4,4)) print(dp_func2(4,4)) Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-04-12 "},"question/ALG/常见算法.html":{"url":"question/ALG/常见算法.html","title":"常见算法","keywords":"","body":"合并有序数组 from typing import List # 方法一 时间复杂度O(m+k),空间复杂度O(k) def merge_list(lst1:List[int],lst2:[int]): l1, l2 = len(lst1), len(lst2) lst1 += l2 * [0] # 控制空间复杂度到k=len(lst2) l1,l2,cur = l1 - 1, l2 - 1,l1 + l2 - 1 while cur >= 0 and l2 >= 0: if lst1[l1] > lst2[l2]: lst1[cur] = lst1[l1] l1 -= 1 else: lst1[cur] = lst2[l2] l2 -= 1 cur -= 1 lst1[:l2+1] = lst2[0:l2+1] return lst1 # 方法二 O(NlogN) 空间复杂度O(k) k=len(lst2) def merge_list2(lst1:List[int],lst2:List[int]): lst1.extend(lst2) lst1.sort() return lst1 print(merge_list([1,3,11],[2,12,15,18])) 替换空格 class Solution: def replaceSpace(self, s: str) -> str: l = len(s) nums = s.count(' ') n_l = l + (nums 两个数组相对排序 from typing import List class Solution: # 方法一 sort(key) def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]: ranks = {x: i for i, x in enumerate(arr2)} arr1.sort(key=lambda x:(0,ranks[x]) if x in ranks else (1,x)) return arr1 # 方法二 计数排序法 def relativeSortArray2(self,arr1: List[int], arr2: List[int]) -> List[int]: upper = max(arr1) frequency = [0] * (upper + 1) for x in arr1: frequency[x] += 1 ans = list() for x in arr2: ans.extend([x] * frequency[x]) frequency[x] = 0 for x in range(upper + 1): if frequency[x] > 0: ans.extend([x] * frequency[x]) return ans # 通过sort()参数指定键排序 arr1,arr2 = [2,3,1,3,2,4,6,7,9,2,20,19,5,1],[2,4,3,6] print(Solution().relativeSortArray(arr1,arr2)) Z字变换 # 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列 # 输入：s = \"PAYPALISHIRING\", numRows = 3 # 输出：\"PAHNAPLSIIGYIR\" # 输入：s = \"PAYPALISHIRING\", numRows = 4 # 输出：\"PINALSIGYAHRPI\" # 以 V 字型为一个循环, 循环周期为 n = (2 * numRows - 2) # 索引值i：计算 x = i % n , 行号y = min(x, n - x) class Solution: def convert(self, s: str, numRows: int) -> str: if numRows == 1: return s rows = [\"\"] * numRows n = 2 * numRows - 2 for i, char in enumerate(s): x = i % n rows[min(x, n - x)] += char return \"\".join(rows) # 测试代码 print(Solution().convert('PAYPALISHIRING',4)) 移除K位数后的最小数字 class Solution: def removeKdigits(self, num: str, k: int) -> str: stack = [] n = len(num) - k for digit in num: while k and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) res = ''.join(stack[:n]).lstrip('0') return res or '0' #UT print(Solution().removeKdigits('1432219',3)) 顺时针打印矩阵（剥洋葱打印） from typing import List class Solution: def spiralOrder(self, matrix: List[List[int]]) -> List[int]: res = [] while matrix: res += matrix.pop(0) matrix = list(zip(*matrix))[::-1] return res matrix = [[1,2,3],[4,5,6],[7,8,9]] print(Solution().spiralOrder(matrix)) 杨辉三角 from typing import List class Solution: def generate(self, numRows: int) -> List[List[int]]: ret = [] for i in range(1, numRows + 1): tmp = [1 for _ in range(i)] for j in range(1, len(tmp) - 1): # i - 2 tmp[j] = ret[i - 2][j - 1] + ret[i - 2][j] ret.append(tmp) return ret # UT print(Solution().generate(5)) 整数反转 class Solution: def reverse(self, x: int) -> int: # 特殊情况0 if x == 0: return 0 # 边界判断，既要判断输入还要判断输出 def _f(x): if 2**31 0: k = int(_reverse(x)) else: k = -int(_reverse(-x)) if _f(k): return k else: return 0 # UT print(Solution().reverse(-123)) 回文数验证 class Solution: # 方法一：转字符串 def isPalindrome(self, s: int) -> bool: return False if x bool: if xans: ans = ans*10 + x%10 # 答案*10+新末尾数 x //= 10 # 新末尾数 = 原数字的最后一位 return x==ans or x==(ans//10) # UT print(Solution().isPalindrome2(101)) 回文串验证（忽略标点/空格符） class Solution: # 筛选判断：O(N) O(N) def isPalindrome(self, s: str) -> bool: sgood = \"\".join(ch.lower() for ch in s if ch.isalnum()) return sgood == sgood[::-1] # 双指针原地判断：O(N) O(1) def isPalindrome2(self, s: str) -> bool: n = len(s) left, right = 0, n - 1 while left 回文串排列（是否存在） # 位元算 a, b = 1 bool: n = 0 for i in s: n ^= 1 bool: import collections return sum(1 for k, v in collections.Counter(s).items() if v % 2 != 0) bool: my_set = set() for ch in s: if ch in my_set: my_set.remove(ch) else: my_set.add(ch) return len(my_set) 有效括号 def isValid(s: str) -> bool: if len(s) % 2 == 1: return False dic = {\")\": \"(\",\"]\": \"[\",\"}\": \"{\"} stack = [] for i in s: if stack and i in dic: # 如果栈不空，且i为有效右括号 if stack[-1] == dic[i]: # 如果栈顶为对应的左括号，则弹出 stack.pop() else: return False # 如果栈顶不是对应的左括号，则不匹配 else: stack.append(i) # 如果i为左括号（非右括号都会），入栈 return not stack def isValid2(s: str) -> bool: arr = ['{}', '[]', '()'] l = len(s) // 2 print(l) i = 0 while i 罗马数字转整数 def roman2int(s: str) -> int: dic = {'I': 1, 'IV': 4, 'V': 5, 'IX': 9, 'X': 10, 'XL': 40, 'L': 50, 'XC': 90, 'C': 100, 'CD': 400, 'D': 500, 'CM': 900, 'M': 1000} su = [] i = 0 while i 删除有序列表中重复元素后的新列表长度 from typing import List def removeDuplicates(nums: List[int]) -> int: if not nums: return 0 i = 0 for j in range(1, len(nums)): if nums[i] != nums[j]: i += 1 nums[i] = nums[j] return i + 1 a = [0,1,1,2,3,3,4] print(removeDuplicates(a)) 列表中移除某元素 from typing import List def removeElement(nums: List[int], val: int): # 倒序遍历，避免pop()后取值索引-1导致的取值问题 for i in range(len(nums) - 1, -1, -1): if nums[i] == val: nums.pop(i) return len(nums) # UT nums, val = [3, 2, 2, 3, 5, 7], 3 print(removeElement(nums, val)) Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-04-12 "},"question/ALG/业务题例.html":{"url":"question/ALG/业务题例.html","title":"业务题例","keywords":"","body":"字段入库（重复字高的，不做新纪录） # 将重复率3个字的值，累加次数，不再新纪录 def check(text1,text2,dis=3): DIS = 0 for i in text1: if i in text2: DIS += 1 if DIS >= dis: return True return False _dict = {} def save(text): for key in _dict.keys(): if check(text,key): _dict[key] += 1 return '已经存在' _dict[text] = 1 return f'新增:{text}' save('机器') save('机器故障') save('机器故障问题') print(_dict) Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-04-10 "},"question/DATA/":{"url":"question/DATA/","title":"数据库","keywords":"","body":"Database MySQL Neo4j Redis MongoDB Other Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-03-29 "},"question/Project/经销商展厅系统.html":{"url":"question/Project/经销商展厅系统.html","title":"Project","keywords":"","body":"Copyright © 2021 zbmain.  all right reserved，powered by Gitbook本页修订时间： 2021-04-17 "}}